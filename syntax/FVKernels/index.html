<!DOCTYPE html><head><meta charset="UTF-8"><title>FVKernels System | Moltres</title><link href="../../contrib/materialize/materialize.min.css" type="text/css" rel="stylesheet" media="screen,projection"></link><link href="../../contrib/prism/prism.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/devel_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/alert_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/content_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/sqa_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/civet_moose.css" type="text/css" rel="stylesheet"></link><link href="../../contrib/katex/katex.min.css" type="text/css" rel="stylesheet"></link><link href="../../css/katex_moose.css" type="text/css" rel="stylesheet"></link><link href="../../css/moltres.css" type="text/css" rel="stylesheet"></link><script type="text/javascript" src="../../contrib/jquery/jquery.min.js"></script><script type="text/javascript" src="../../contrib/katex/katex.min.js"></script></head><body><div class="page-wrap"><header><nav><div class="nav-wrapper container"><a href="../../index.html" class="left moose-logo hide-on-med-and-down">Moltres</a><a href="https://github.com/arfc/moltres" class="right"><img src="../../media/framework/github-logo.png" class="github-mark"></img><img src="../../media/framework/github-mark.png" class="github-logo"></img></a><ul class="right hide-on-med-and-down"><li><a href="#!" class="dropdown-trigger" data-target="c605ed59-4e47-456f-81bb-7928eb5f3d36" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="56d4332b-7fe6-4787-bafd-19d2fbb0602b" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="b33c7705-4e4a-4d32-a42b-41cbf5d868ee" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#" class="sidenav-trigger" data-target="d92b3705-f835-4e26-a2d0-dfbaa4269339"><i class="material-icons">menu</i></a><ul class="sidenav" id="d92b3705-f835-4e26-a2d0-dfbaa4269339"><li><a href="#!" class="dropdown-trigger" data-target="7ad6dc52-e1d3-4952-a7cb-4e52b865fe2e" data-constrainWidth="false">Getting Started<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="949ac3d0-49cb-47f2-82cd-388c309118f7" data-constrainWidth="false">Documentation<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="#!" class="dropdown-trigger" data-target="1763a4b2-bfa9-45cc-a0cd-52e3224fb509" data-constrainWidth="false">Help<i class="material-icons right">arrow_drop_down</i></a></li><li><a href="../../citing.html">Citing</a></li></ul><a href="#moose-search" class="modal-trigger"><i class="material-icons">search</i></a></div><ul class="dropdown-content" id="c605ed59-4e47-456f-81bb-7928eb5f3d36"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="56d4332b-7fe6-4787-bafd-19d2fbb0602b"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="b33c7705-4e4a-4d32-a42b-41cbf5d868ee"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul><ul class="dropdown-content" id="7ad6dc52-e1d3-4952-a7cb-4e52b865fe2e"><li><a href="../../getting_started/installation.html">Install Moltres</a></li><li><a href="../../getting_started/tutorials.html">Tutorials</a></li></ul><ul class="dropdown-content" id="949ac3d0-49cb-47f2-82cd-388c309118f7"><li><a href="../index.html">Moltres Syntax</a></li><li><a href="https://mooseframework.inl.gov/source/index.html">MOOSE Syntax</a></li><li><a href="../../doxygen/classes.html">Moltres Doxygen</a></li><li><a href="https://mooseframework.inl.gov/docs/doxygen/moose/classes.html">MOOSE Doxygen</a></li><li><a href="../../development/contributing.html">Contributing</a></li><li><a href="../../publications.html">List of Publications</a></li></ul><ul class="dropdown-content" id="1763a4b2-bfa9-45cc-a0cd-52e3224fb509"><li><a href="https://github.com/arfc/moltres/discussions">Moltres Discussion Forum</a></li><li><a href="https://github.com/idaholab/moose/discussions">MOOSE Discussion Forum</a></li></ul></nav><div class="modal modal-fixed-footer moose-search-modal" id="moose-search"><div class="modal-content container moose-search-modal-content"><div class="row"><div class="col l12"><div class="input-field"><input type_="text" onkeyup="mooseSearch()" placeholder="/index.md" id="moose-search-box"></input></div></div><div><div class="col s12" id="moose-search-results"></div></div></div></div><div class="modal-footer"><a href="#!" class="modal-close btn-flat">Close</a></div></div></header><main class="main"><div class="container"><div class="row"><div class="col hide-on-med-and-down l12"><nav class="breadcrumb-nav"><div class="nav-wrapper"><a href=".." class="breadcrumb">syntax</a><a href="." class="breadcrumb">FVKernels</a></div></nav></div></div><div class="row"><div class="moose-content col s12 m12 l10"><section id="19ca5b26-acd9-41d0-8b38-beaac9e72a66" data-section-level="1" data-section-text="FVKernels System"><h1 id="fvkernels-system">FVKernels System</h1><p>For an overview of MOOSE FV please see <a href="../../finite_volumes/fv_design.html">Finite Volume Design Decisions in MOOSE</a>.</p><p>For the finite volume method (FVM), <code>FVKernels</code> are the base class for <code>FVFluxKernel</code>, <code>FVElementalKernel</code>. These specialized objects satisfy the following tasks:</p><p>* <code>FVFluxKernel</code> represents numerical fluxes evaluate on the element faces.   These terms originate from applying Gauss&#x27; divergence theorem.</p><p>* <code>FVElementalKernel</code> represents terms that do not contain a spatial   derivative so that Gauss&#x27; theorem cannot be applied. These terms include   time derivatives, externally imposed source terms, and reaction terms.</p><p>Note: Currently, the <code>FVElementalKernel</code> category only contains kernels (subclasses) representing time derivatives. Kernels representing externally imposed sources or reaction terms will be added in the near future.</p><div class="card moose-alert moose-alert-note"><div class="card-title moose-alert-title"><i class="material-icons moose-inline-icon">comment</i><span class="moose-alert-title-brand">note</span></div><div class="card-content"><div class="moose-alert-content"><p><p>In the documentation that follows, we will use &#x27;-&#x27; and &#x27;<strong>&#x27; to represent different sides of a face. This is purely notation. In the MOOSE code base, the &#x27;-&#x27; side is represented with an <code>_elem</code> suffix and the &#x27;</strong>&#x27; side is represented with a <code>_neighbor</code> suffix. We could just as well have chosen <code>_left</code> and <code>_right</code>, or <code>_1</code> and <code>_2</code>, or <code>_minus</code> and <code>_plus</code>, but for consistency with previous MOOSE framework code such as discontinuous Galerkin kernels and node-face constraints, we have elected to go with the <code>_elem</code> and <code>_neighbor</code> suffixes.</p></p></div></div></div><section class="scrollspy" id="e2d0c9d7-6cbb-449d-a706-881d3e9c5630" data-section-level="2" data-section-text="FVKernels block"><h2 id="fvkernels-block">FVKernels block</h2><p>FVM kernels are added to simulation input files in the <code>FVKernels</code> block.  The <code>FVKernels</code> block in the example below sets up a transient diffusion problem defined by the equation:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-6d06910e-1097-48ca-9dc5-f45d36419c83"></span><script>var element = document.getElementById("moose-equation-6d06910e-1097-48ca-9dc5-f45d36419c83");katex.render("  \\frac{\\partial v}{\\partial t} - \\nabla \\cdot D \\nabla v = 0.", element, {displayMode:true,throwOnError:false});</script></span></p><p>The time derivative term corresponds to the kernel named <code>time</code>, while the diffusion term is represented by the kernel named <code>diff</code>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 1: </span><span class="moose-caption-text">Example of the FVKernels block in a MOOSE input file.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[FVKernels]
  [./time]
    type = FVTimeKernel
    variable = v
  [../]
  [diff]
    type = FVDiffusion
    variable = v
    coeff = coeff
  []
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#bc836ae9-112c-42d4-a9bb-947815d080b8">(moose/test/tests/fvkernels/fv_simple_diffusion/transient.i)</a></div></div><p>The <code>FVTimeKernel</code> in the example derives from <code>FVElementalKernel</code> so it&#x27;s a volumetric contribution to the residual, while the <code>FVDiffusion</code> kernel is an <code>FVFluxKernel</code> and it&#x27;s a face contribution to the residual. The remaining MOOSE syntax is what you would expect to see in finite element kernel objects:</p><p>* <code>variable</code> refers to the variable that this kernel is acting on (i.e. into   which equation does the residual of this term go).  This must be a   finite-volume variable (defined with <code>fv = true</code>) for all FVM kernels.</p><p>* <code>coeff</code> in kernel <code>diff</code> is a material property corresponding to the heat conduction or diffusion coefficient.</p><p>The next example shows an <code>FVKernels</code> block that solves the one-dimensional Burgers&#x27; equation. The Burgers&#x27; equation for speed <code>v</code> is given by:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-efa36cae-8b44-4747-8516-7634a756bdb4"></span><script>var element = document.getElementById("moose-equation-efa36cae-8b44-4747-8516-7634a756bdb4");katex.render("  \\frac{\\partial v}{\\partial t} + \\frac{1}{2}\\frac{\\partial }{\\partial x} v^2 = 0.", element, {displayMode:true,throwOnError:false});</script></span></p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 2: </span><span class="moose-caption-text">Example of the FVKernels block in a MOOSE input file for solving one-dimensional Burgers&#x27; equation.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-text">[FVKernels]
  [./burgers]
    type = FVBurgers1D
    variable = v
  [../]
  [./time]
    type = FVTimeKernel
    variable = v
  [../]
[]
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#a4c5f14b-dcba-4c3d-94c8-13b8db15e295">(moose/test/tests/fvkernels/fv_burgers/fv_burgers.i)</a></div></div><p>Note that the <code>FVBurgers1D</code> kernel only works for one-dimensional problems. In this example, the exact same time derivative kernels as for the diffusion example is used, but the spatial derivative term is different.</p><p>Boundary conditions are not discussed in these examples. Look at <a href="../FVBCs/index.html">syntax files</a> for details about boundary conditions.</p></section><section class="scrollspy" id="9beb0ace-76eb-4d3f-b91a-a4c4f73af215" data-section-level="2" data-section-text="Available Objects"><h2 id="available-objects">Available Objects</h2><ul class="moose-syntax-list collection with-header"><li class="collection-header">Moose App</li><li class="collection-item"><a href="../../source/fvkernels/FVAdvection.html">FVAdvection</a>Residual contribution from advection operator for finite volume method.</li><li class="collection-item"><a href="../../source/fvkernels/FVBodyForce.html">FVBodyForce</a>Demonstrates the multiple ways that scalar values can be introduced into finite volume kernels, e.g. (controllable) constants, functions, and postprocessors.</li><li class="collection-item"><a href="../../source/fvkernels/FVCoupledForce.html">FVCoupledForce</a>Implements a source term proportional to the value of a coupled variable.</li><li class="collection-item"><a href="../../source/fvkernels/FVDiffusion.html">FVDiffusion</a>Computes residual for diffusion operator for finite volume method.</li><li class="collection-item"><a href="../../source/fvkernels/FVMatAdvection.html">FVMatAdvection</a>Computes the residual of advective term using finite volume method.</li><li class="collection-item"><a href="../../source/fvkernels/FVOrthogonalDiffusion.html">FVOrthogonalDiffusion</a>Imposes an orthogonal diffusion term.</li><li class="collection-item"><a href="../../source/fvkernels/FVReaction.html">FVReaction</a>Simple consuming reaction term</li><li class="collection-item"><a href="../../source/fvkernels/FVScalarLagrangeMultiplier.html">FVScalarLagrangeMultiplier</a>This class is used to enforce integral of phi = volume * phi_0 with a Lagrange multiplier approach.</li><li class="collection-item"><a href="../../source/fvkernels/FVTimeKernel.html">FVTimeKernel</a>Residual contribution from time derivative of a variable for the finite volume method.</li><li class="collection-header">Heat Conduction App</li><li class="collection-item">FVHeatConductionTimeDerivativeAD Time derivative term <span class="moose-katex-inline-equation" id="moose-equation-7709d26f-df12-4089-8ab8-b0f27620c258"><script>var element = document.getElementById("moose-equation-7709d26f-df12-4089-8ab8-b0f27620c258");katex.render("\\rho c_p \\frac{\\partial T}{\\partial t}", element, {displayMode:false,throwOnError:false});</script></span> of the heat equation for quasi-constant specific heat <span class="moose-katex-inline-equation" id="moose-equation-b86444e9-a1be-4bd6-9062-dd575806a2d2"><script>var element = document.getElementById("moose-equation-b86444e9-a1be-4bd6-9062-dd575806a2d2");katex.render("c_p", element, {displayMode:false,throwOnError:false});</script></span> and the density <span class="moose-katex-inline-equation" id="moose-equation-3d171b5b-4d11-4fc9-b797-52f1129c0f5f"><script>var element = document.getElementById("moose-equation-3d171b5b-4d11-4fc9-b797-52f1129c0f5f");katex.render("\\rho", element, {displayMode:false,throwOnError:false});</script></span>.</li><li class="collection-header">Navier Stokes App</li><li class="collection-item">CNSFVFluidEnergyHLLCImplements the fluid energy flux portion of the free-flow HLLC discretization.</li><li class="collection-item">CNSFVMassHLLCImplements the mass flux portion of the free-flow HLLC discretization.</li><li class="collection-item">CNSFVMomentumHLLCImplements the momentum flux portion of the free-flow HLLC discretization.</li><li class="collection-item">FVMatPropTimeKernelReturns a material property which should correspond to a time derivative.</li><li class="collection-item">FVPorosityTimeDerivativeA time derivative multiplied by a porosity material property</li><li class="collection-item">INSFVEnergyAdvectionAdvects energy, e.g. rho*cp*T. A user may still override what quantity is advected, but the default is rho*cp*T</li><li class="collection-item">INSFVEnergyTimeDerivativeAdds the time derivative term to the incompressible Navier-Stokes energy equation.</li><li class="collection-item">INSFVMassAdvectionObject for advecting mass, e.g. rho</li><li class="collection-item">INSFVMixingLengthReynoldsStressComputes the force due to the Reynolds stress term in the incompressible Reynolds-averaged Navier-Stokes equations.</li><li class="collection-item">INSFVMixingLengthScalarDiffusionComputes the turbulent diffusive flux that appears in Reynolds-averaged fluid conservation equations.</li><li class="collection-item">INSFVMomentumAdvectionObject for advecting momentum, e.g. rho*u</li><li class="collection-item">INSFVMomentumBoussinesqComputes a body force for natural convection buoyancy.</li><li class="collection-item">INSFVMomentumGravityComputes a body force due to gravity.</li><li class="collection-item">INSFVMomentumPressureIntroduces the coupled pressure term into the Navier-Stokes momentum equation.</li><li class="collection-item">INSFVMomentumTimeDerivativeAdds the time derivative term to the incompressible Navier-Stokes momentum equation.</li><li class="collection-item">INSFVScalarFieldAdvectionAdvects an arbitrary quantity. If the &#x27;advected_quantity&#x27; parameter is specified, it will be used. Else the default is to advect the associated nonlinear &#x27;variable&#x27;.</li><li class="collection-item">NSFVEnergyAmbientConvectionImplements a solid-fluid ambient convection volumetric term proportional to the difference between the fluid and ambient temperatures : <span class="moose-katex-inline-equation" id="moose-equation-d2a95f4b-8ecd-4396-81c8-e10442907d7e"><script>var element = document.getElementById("moose-equation-d2a95f4b-8ecd-4396-81c8-e10442907d7e");katex.render("q''' = \\alpha (T_{fluid} - T_{ambient})", element, {displayMode:false,throwOnError:false});</script></span>.</li><li class="collection-item">NSFVMomentumFrictionImplements a basic linear or quadratic friction model as a volumetric force, for example for the X-momentum equation: <span class="moose-katex-inline-equation" id="moose-equation-0669dbba-6787-42fe-9bd1-6ff6b9e7cec3"><script>var element = document.getElementById("moose-equation-0669dbba-6787-42fe-9bd1-6ff6b9e7cec3");katex.render("F_x = - C_l * v_x", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-87303322-8886-4382-b27e-6efd3dc50e44"><script>var element = document.getElementById("moose-equation-87303322-8886-4382-b27e-6efd3dc50e44");katex.render("F_x = - C_q * v_x * |v_x|", element, {displayMode:false,throwOnError:false});</script></span> for the linear and quadratic models respectively. A linear dependence is expected for laminar flow, while a quadratic dependence is more common for turbulent flow.</li><li class="collection-item">NSFVMomentumGravityComputes a body force due to gravity.</li><li class="collection-item">PCNSFVDensityTimeDerivativeA time derivative kernel for which the form is eps * ddt(rho*var).</li><li class="collection-item">PCNSFVFluidEnergyHLLCImplements the fluid energy flux portion of the porous HLLC discretization.</li><li class="collection-item">PCNSFVKTComputes the residual of advective term using finite volume method.</li><li class="collection-item">PCNSFVKTDCComputes the residual of advective term using finite volume method using a deferred correction approach.</li><li class="collection-item">PCNSFVMassHLLCImplements the mass flux portion of the porous HLLC discretization.</li><li class="collection-item">PCNSFVMomentumHLLCImplements the momentum flux portion of the porous HLLC discretization.</li><li class="collection-item">PINSFVEnergyAdvectionAdvects energy, e.g. rho*cp*T. A user may still override what quantity is advected, but the default is rho*cp*T</li><li class="collection-item">PINSFVEnergyAmbientConvectionImplements the solid-fluid ambient convection term in the porous media Navier Stokes energy equation.</li><li class="collection-item">PINSFVEnergyDiffusionDiffusion term in the porous media incompressible Navier-Stokes fluid energy equations :  <span class="moose-katex-inline-equation" id="moose-equation-fcb5147f-198f-41cd-880a-cc8cbe287f5e"><script>var element = document.getElementById("moose-equation-fcb5147f-198f-41cd-880a-cc8cbe287f5e");katex.render("-div(eps * k * grad(T))", element, {displayMode:false,throwOnError:false});</script></span></li><li class="collection-item">PINSFVEnergyEffectiveDiffusionEffective diffusion term in the porous media incompressible Navier-Stokes equations : -div(kappa grad(T))</li><li class="collection-item">PINSFVEnergyTimeDerivativeAdds the time derivative term to the Navier-Stokes energy equation: for fluids: eps * rho * cp * dT/dt, for solids: (1 - eps) * rho * cp * dT/dt</li><li class="collection-item">PINSFVMassAdvectionObject for advecting mass in porous media mass equation</li><li class="collection-item">PINSFVMomentumAdvectionObject for advecting superficial momentum, e.g. rho*u_d, in the porous media momentum equation</li><li class="collection-item">PINSFVMomentumAdvectionPorosityGradientPorosity gradient spun from the advection term for the porous media Navier Stokes momentum equation.</li><li class="collection-item">PINSFVMomentumBoussinesqComputes a body force for natural convection buoyancy in porous media: eps alpha (T-T_0)</li><li class="collection-item">PINSFVMomentumDiffusionViscous diffusion term, div(mu grad(u_d / eps)), in the porous media incompressible Navier-Stokes momentum equation.</li><li class="collection-item">PINSFVMomentumFrictionComputes a friction force term on fluid in porous media in the Navier Stokes i-th momentum equation.</li><li class="collection-item">PINSFVMomentumGravityComputes a body force, <span class="moose-katex-inline-equation" id="moose-equation-d2fd67d2-0308-4e9d-84db-f8c08f3143a7"><script>var element = document.getElementById("moose-equation-d2fd67d2-0308-4e9d-84db-f8c08f3143a7");katex.render("eps * \rho * g", element, {displayMode:false,throwOnError:false});</script></span> due to gravity on fluid in porous media.</li><li class="collection-item">PINSFVMomentumPressureIntroduces the coupled pressure term <span class="moose-katex-inline-equation" id="moose-equation-650dae7c-5dda-4d15-84a4-7ddf81651b32"><script>var element = document.getElementById("moose-equation-650dae7c-5dda-4d15-84a4-7ddf81651b32");katex.render("eps  abla P", element, {displayMode:false,throwOnError:false});</script></span> into the Navier-Stokes porous media momentum equation.</li><li class="collection-item">PINSFVMomentumPressureFluxMomentum pressure term eps grad_P, as a flux kernel using the divergence theoreom, in the porous media incompressible Navier-Stokes momentum equation. This kernel is also executed on boundaries.</li><li class="collection-item">PINSFVMomentumPressurePorosityGradientIntroduces the coupled pressure times porosity gradient term into the Navier-Stokes porous media momentum equation.</li><li class="collection-item">PINSFVMomentumTimeDerivativeAdds the time derivative term: d(rho u_d) / dt to the porous media incompressible Navier-Stokes momentum equation.</li><li class="collection-item">PNSFVEnergyTimeDerivativeAdds the time derivative term to the Navier-Stokes energy equation: for fluids: eps * rho * cp * dT/dt, for solids: (1 - eps) * rho * cp * dT/dt</li><li class="collection-item">PNSFVMomentumFrictionComputes a friction force term on fluid in porous media in the Navier Stokes i-th momentum equation.</li><li class="collection-item">PNSFVMomentumGravityComputes a body force, <span class="moose-katex-inline-equation" id="moose-equation-0b46e8e0-bbad-4a09-a783-99757a0d5283"><script>var element = document.getElementById("moose-equation-0b46e8e0-bbad-4a09-a783-99757a0d5283");katex.render("eps * \rho * g", element, {displayMode:false,throwOnError:false});</script></span> due to gravity on fluid in porous media.</li><li class="collection-item">PNSFVMomentumPressureRZAdds the porous <span class="moose-katex-inline-equation" id="moose-equation-31b1d07d-debb-444e-8a03-6bd8082ba0b5"><script>var element = document.getElementById("moose-equation-31b1d07d-debb-444e-8a03-6bd8082ba0b5");katex.render("-p/r", element, {displayMode:false,throwOnError:false});</script></span> term into the radial component of the Navier-Stokes momentum equation for the problems in the RZ coordinate system.</li><li class="collection-item">PNSFVPGradEpsilonIntroduces a -p * grad_eps term.</li></ul></section><section class="scrollspy" id="276882c1-4242-4462-9f64-598c0d1dc519" data-section-level="2" data-section-text="FVKernel source code : FVDiffusion example"><h2 id="fvkernel-source-code-fvdiffusion-example">FVKernel source code: FVDiffusion example</h2><p>First, <code>FVFluxKernels</code> are discussed.  <code>FVFluxKernels</code> are used to calculate numerical flux contributions from face (surface integral) terms to the residual. The residual contribution is implemented by overriding the <code>computeQpResidual</code> function.</p><p>In the FVM, one solves for the averages of the variables over each element. The values of the variables on the faces are unknown and must be computed from the cell average values. This interpolation/reconstruction determines the accuracy of the FVM. The discussion is based on the example of <code>FVDiffusion</code> that discretizes the diffusion term using a central difference approximation.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 3: </span><span class="moose-caption-text">Example source code for a finite volume kernel discretizing the diffusion term using a central difference.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#include &quot;FVDiffusion.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FVDiffusion);

InputParameters
FVDiffusion::validParams()
{
  InputParameters params = FVFluxKernel::validParams();
  params.addClassDescription(&quot;Computes residual for diffusion operator for finite volume method.&quot;);
  params.addRequiredParam&lt;MaterialPropertyName&gt;(&quot;coeff&quot;, &quot;diffusion coefficient&quot;);
  params.set&lt;unsigned short&gt;(&quot;ghost_layers&quot;) = 2;
  return params;
}

FVDiffusion::FVDiffusion(const InputParameters &amp; params)
  : FVFluxKernel(params),
    _coeff_elem(getADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;)),
    _coeff_neighbor(getNeighborADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;))
{
}

ADReal
FVDiffusion::computeQpResidual()
{
  auto dudn = gradUDotNormal();

  // Eventually, it will be nice to offer automatic-switching triggered by
  // input parameters to change between different interpolation methods for
  // this.
  ADReal k;
  interpolate(Moose::FV::InterpMethod::Average,
              k,
              _coeff_elem[_qp],
              _coeff_neighbor[_qp],
              *_face_info,
              true);

  return -1 * k * dudn;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#dd854ee5-1b78-4cb8-815e-c513a8664e13">(moose/framework/src/fvkernels/FVDiffusion.C)</a></div></div><p>The kernel <code>FVDiffusion</code> discretizes the diffusion term <span class="moose-katex-inline-equation" id="moose-equation-5bd1946b-c31c-43ec-b723-069e3081733e"><script>var element = document.getElementById("moose-equation-5bd1946b-c31c-43ec-b723-069e3081733e");katex.render("-\\nabla \\cdot D(v,\\vec{r}) \\nabla v", element, {displayMode:false,throwOnError:false});</script></span>. Integrating over the extend of an element and using Gauss&#x27; theorem leads to:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-4272f8f9-3839-4d0d-9584-f32f5e96994e"></span><script>var element = document.getElementById("moose-equation-4272f8f9-3839-4d0d-9584-f32f5e96994e");katex.render("-  \\int_{\\Omega} \\nabla \\cdot D(v,\\vec{r}) \\nabla v dV =  \\int_{\\partial \\Omega} \\left(-D(v, \\vec{r}) \\vec{n}\\cdot \\nabla v \\right) dS.", element, {displayMode:true,throwOnError:false});</script></span></p><p>The term in parenthesis in the surface integral on the right hand side must be implemented in the <code>FVKernel</code>. However, there is one more step before we can implement the kernel. We must determine how the values of <span class="moose-katex-inline-equation" id="moose-equation-c304aa72-9468-487b-aaa9-82fe994623a3"><script>var element = document.getElementById("moose-equation-c304aa72-9468-487b-aaa9-82fe994623a3");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-17601c9f-79a7-40ac-b55c-bfba47fe30f3"><script>var element = document.getElementById("moose-equation-17601c9f-79a7-40ac-b55c-bfba47fe30f3");katex.render("\\nabla v", element, {displayMode:false,throwOnError:false});</script></span> depend on the values of <span class="moose-katex-inline-equation" id="moose-equation-08bba6cd-6b0f-4bfa-978a-d2d8753edefa"><script>var element = document.getElementById("moose-equation-08bba6cd-6b0f-4bfa-978a-d2d8753edefa");katex.render("D", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-10356637-5b6a-44a4-9bdc-9456205101b7"><script>var element = document.getElementById("moose-equation-10356637-5b6a-44a4-9bdc-9456205101b7");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span> on the &#x27;+&#x27; and &#x27;-&#x27; side of the face <span class="moose-katex-inline-equation" id="moose-equation-a8d9c67b-d91f-4009-b2ad-668948e14d55"><script>var element = document.getElementById("moose-equation-a8d9c67b-d91f-4009-b2ad-668948e14d55");katex.render("\\partial \\Omega", element, {displayMode:false,throwOnError:false});</script></span>.  In this example, the following approximation is used:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-773c1773-5291-4539-a4f3-d296e40d0867"></span><script>var element = document.getElementById("moose-equation-773c1773-5291-4539-a4f3-d296e40d0867");katex.render("    \\left(-D(\\vec{r}) \\vec{n}\\cdot \\nabla v \\right) \\approx \\frac{D(v_L,\\vec{r}_L) + D(v_R,\\vec{r}_R)}{2} \\frac{v_R - v_L}{\\|\\vec{r}_R - \\vec{r}_L\\|}", element, {displayMode:true,throwOnError:false});</script></span></p><p>This is a central difference approximation of the gradient on the face that neglects cross diffusion terms.</p><p>Now, the implementation of this numerical flux into <code>FVDiffusion::computeQpResidual</code> is discussed.</p><p>* the kernel provides the &#x27;-&#x27; and &#x27;+&#x27; values of the variable <span class="moose-katex-inline-equation" id="moose-equation-653d6b6b-a8a0-4327-8c67-d8eb53d1115f"><script>var element = document.getElementById("moose-equation-653d6b6b-a8a0-4327-8c67-d8eb53d1115f");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span> as <code>_u_elem[_qp]</code> and <code>_u_neighbor[_qp]</code></p><p>* the values of the material properties on the &#x27;-&#x27; side of the face is obtained by <code>_coeff_elem(getADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;))</code> while the &#x27;+&#x27; side value is obtained by calling <code>getNeighborADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;)</code>.</p><p>* geometric information about the &#x27;-&#x27; and &#x27;+&#x27; adjacent elements is available from the <code>face_info</code> object.</p><p>The implementation is then straight forward. The first line of the code computes <code>dudn</code> which corresponds to the term:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-1d0bd3ec-e618-442a-bfbe-a6867277be8a"></span><script>var element = document.getElementById("moose-equation-1d0bd3ec-e618-442a-bfbe-a6867277be8a");katex.render(" \\text{dudn} = \\frac{v_R - v_L}{\\|\\vec{r}_R - \\vec{r}_L\\|}", element, {displayMode:true,throwOnError:false});</script></span></p><p>while the second line computes <code>k</code> corresponding to:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-34c9bd6f-f87e-4f4a-bca1-9a780a238a2c"></span><script>var element = document.getElementById("moose-equation-34c9bd6f-f87e-4f4a-bca1-9a780a238a2c");katex.render("  \\text{k} = \\frac{D(v_L,\\vec{r}_L) + D(v_R,\\vec{r}_R)}{2} .", element, {displayMode:true,throwOnError:false});</script></span></p><p>The minus sign originates from the minus sign in the original expression. Flow from &#x27;-&#x27; to &#x27;+ is defined to be positive.</p></section><section class="scrollspy" id="bbd2c3de-f68e-44e9-a7ab-07345fe30af8" data-section-level="2" data-section-text="FVKernel source code : FVMatAdvection example"><h2 id="fvkernel-source-code-fvmatadvection-example">FVKernel source code: FVMatAdvection example</h2><p>In this example the advection term:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-cdb87c25-183a-442f-8b50-d961d7957fd9"></span><script>var element = document.getElementById("moose-equation-cdb87c25-183a-442f-8b50-d961d7957fd9");katex.render("  \\nabla \\cdot \\left( \\vec{u} v \\right)", element, {displayMode:true,throwOnError:false});</script></span></p><p>is discretized using upwinding. The velocity is denoted by <span class="moose-katex-inline-equation" id="moose-equation-49860f02-74be-40e2-8880-9dda17d5447d"><script>var element = document.getElementById("moose-equation-49860f02-74be-40e2-8880-9dda17d5447d");katex.render("\\vec{u}", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-ff275261-b43f-440b-9019-4bf539812a87"><script>var element = document.getElementById("moose-equation-ff275261-b43f-440b-9019-4bf539812a87");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span> represents a passive scalar quantity advected by the flow. Upwinding is a strategy that approximates the value of a variable on a face by taking the value from the upwind element (i.e. the element where the flow originates from).</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 4: </span><span class="moose-caption-text">Example source code for a finite volume kernel discretizing advection of a passive scalar.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">
#include &quot;FVDiffusion.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FVDiffusion);

InputParameters
FVDiffusion::validParams()
{
  InputParameters params = FVFluxKernel::validParams();
  params.addClassDescription(&quot;Computes residual for diffusion operator for finite volume method.&quot;);
  params.addRequiredParam&lt;MaterialPropertyName&gt;(&quot;coeff&quot;, &quot;diffusion coefficient&quot;);
  params.set&lt;unsigned short&gt;(&quot;ghost_layers&quot;) = 2;
  return params;
}

FVDiffusion::FVDiffusion(const InputParameters &amp; params)
  : FVFluxKernel(params),
    _coeff_elem(getADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;)),
    _coeff_neighbor(getNeighborADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;))
{
}

ADReal
FVDiffusion::computeQpResidual()
{
  auto dudn = gradUDotNormal();

  // Eventually, it will be nice to offer automatic-switching triggered by
  // input parameters to change between different interpolation methods for
  // this.
  ADReal k;
  interpolate(Moose::FV::InterpMethod::Average,
              k,
              _coeff_elem[_qp],
              _coeff_neighbor[_qp],
              *_face_info,
              true);

  return -1 * k * dudn;
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#8eb53790-538b-4382-ba64-042aea4a3511">(moose/framework/src/fvkernels/FVDiffusion.C)</a></div></div><p>Integrating the advection term over the element and using Gauss&#x27; theorem leads to:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-24005850-e5b9-4661-9971-c2f754f10c32"></span><script>var element = document.getElementById("moose-equation-24005850-e5b9-4661-9971-c2f754f10c32");katex.render("   \\int_{\\Omega}   \\nabla \\cdot \\left( \\vec{u} v \\right) dV =    \\int_{\\partial \\Omega} \\left(\\vec{n} \\cdot \\vec{u} v \\right) dS.", element, {displayMode:true,throwOnError:false});</script></span></p><p>This term in parenthesis on the right hand side is approximated using upwinding:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-62937500-4d21-427b-8be7-de368322450d"></span><script>var element = document.getElementById("moose-equation-62937500-4d21-427b-8be7-de368322450d");katex.render("   \\vec{n} \\cdot \\vec{u} v \\approx  \\tilde{\\vec{u}}\\cdot \\vec{n}    \\tilde{v}    ,", element, {displayMode:true,throwOnError:false});</script></span></p><p>where</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-d07e6ca3-4a75-4c06-b1a5-b25c841269f2"></span><script>var element = document.getElementById("moose-equation-d07e6ca3-4a75-4c06-b1a5-b25c841269f2");katex.render("   \\tilde{\\vec{u}} = \\frac{1}{2} \\left( \\vec{u}_L + \\vec{u}_R \\right)", element, {displayMode:true,throwOnError:false});</script></span></p><p>and  <span class="moose-katex-inline-equation" id="moose-equation-b4d9b7b5-2e1d-49b9-8798-6796a56149dc"><script>var element = document.getElementById("moose-equation-b4d9b7b5-2e1d-49b9-8798-6796a56149dc");katex.render("\\tilde{v} = v_L", element, {displayMode:false,throwOnError:false});</script></span> if <span class="moose-katex-inline-equation" id="moose-equation-8fe0d379-16eb-4c7f-80fb-2fa8b1a1c9c0"><script>var element = document.getElementById("moose-equation-8fe0d379-16eb-4c7f-80fb-2fa8b1a1c9c0");katex.render("\\tilde{\\vec{u}} \\cdot \\vec{n} > 0", element, {displayMode:false,throwOnError:false});</script></span> and <span class="moose-katex-inline-equation" id="moose-equation-545cec54-ae0a-4865-808e-93eaf3916cf0"><script>var element = document.getElementById("moose-equation-545cec54-ae0a-4865-808e-93eaf3916cf0");katex.render("\\tilde{v} = v_R", element, {displayMode:false,throwOnError:false});</script></span> otherwise. By convention, the normal <span class="moose-katex-inline-equation" id="moose-equation-12bf52fd-b8b2-4de3-8ba0-26eed09f6665"><script>var element = document.getElementById("moose-equation-12bf52fd-b8b2-4de3-8ba0-26eed09f6665");katex.render("\\vec{n}", element, {displayMode:false,throwOnError:false});</script></span> points from the &#x27;-&#x27; side to the &#x27;+&#x27; side.</p><p>The implementation is straight forward. In the constructor the &#x27;-&#x27; and &#x27;<strong>&#x27; velocities are obtained as <code>RealVectorValue</code> material properties. The average is computed and stored in variable <code>v_avg</code>. The direction of the flow is determined using the inner product of <code>v_avg * _normal</code> and the residual is then computed using either the &#x27;-&#x27; value of <span class="moose-katex-inline-equation" id="moose-equation-3e2a7a4e-be3b-4e24-a8ee-c62f3fa8c9db"><script>var element = document.getElementById("moose-equation-3e2a7a4e-be3b-4e24-a8ee-c62f3fa8c9db");katex.render("v", element, {displayMode:false,throwOnError:false});</script></span> given by <code>_u_elem[_qp]</code> or the &#x27;</strong>&#x27; value given by <code>_u_neighbor [_qp]</code>.</p></section><section class="scrollspy" id="9291d28c-5e6e-44cd-88f4-302e138b8bae" data-section-level="2" data-section-text="FVKernel source code : FVTimeKernel"><h2 id="fvkernel-source-code-fvtimekernel">FVKernel source code: FVTimeKernel</h2><p>This example demonstrates source code for an <code>FVElementalKernel</code>. <code>FVElementalKernel</code> are volumetric terms. In this case, the kernel is <code>FVTimeKernel</code>.</p><div class="card moose-float"><div class="card-content"><p class="moose-caption"><span class="moose-caption-heading">Listing 5: </span><span class="moose-caption-text">Example source code for the finite volume time kernel.</span></p><pre class="moose-pre" style="max-height:350px;"><code class="language-cpp">FVTimeKernel::computeQpResidual()
{
  return _u_dot[_qp];
}
</code></pre><a class="moose-source-filename tooltipped modal-trigger" href="#e236563c-3d71-498a-ba40-098b71609892">(moose/framework/src/fvkernels/FVTimeKernel.C)</a></div></div><p>This kernel implements the term:</p><p><span class="moose-katex-block-equation"><span class="moose-katex-equation table-cell" id="moose-equation-d2da85d8-4903-4bcd-a853-f09c8c6ec298"></span><script>var element = document.getElementById("moose-equation-d2da85d8-4903-4bcd-a853-f09c8c6ec298");katex.render("  \\frac{\\partial v}{\\partial t}", element, {displayMode:true,throwOnError:false});</script></span></p><p>The implementation is identical to the implementation of FEM kernels except that the FVM does not require multiplication by the test function. </p></section></section><div class="moose-modal modal" id="bc836ae9-112c-42d4-a9bb-947815d080b8"><div class="modal-content"><h4>(moose/test/tests/fvkernels/fv_simple_diffusion/transient.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  type = GeneratedMesh
  dim = 2
  nx = 10
  ny = 10
[]

[Variables]
  [v]
    family = MONOMIAL
    order = CONSTANT
    fv = true
    initial_condition = 7
  []
[]

[Kernels]
[]

[FVKernels]
  [./time]
    type = FVTimeKernel
    variable = v
  [../]
  [diff]
    type = FVDiffusion
    variable = v
    coeff = coeff
  []
[]

[FVBCs]
  [left]
    type = FVDirichletBC
    variable = v
    boundary = left
    value = 7
  []
  [right]
    type = FVDirichletBC
    variable = v
    boundary = right
    value = 42
  []
[]

[Materials]
  [diff]
    type = ADGenericConstantMaterial
    prop_names = &#x27;coeff&#x27;
    prop_values = &#x27;.2&#x27;
  []
[]

[Problem]
  kernel_coverage_check = off
[]

[Executioner]
  type = Transient
  solve_type = &#x27;PJFNK&#x27;
  petsc_options_iname = &#x27;-pc_type -pc_hypre_type&#x27;
  petsc_options_value = &#x27;hypre boomeramg&#x27;
  num_steps = 20
  dt = 0.1
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="a4c5f14b-dcba-4c3d-94c8-13b8db15e295"><div class="modal-content"><h4>(moose/test/tests/fvkernels/fv_burgers/fv_burgers.i)</h4><pre class="moose-pre"><code class="language-text">[Mesh]
  [./gen_mesh]
    type = GeneratedMeshGenerator
    dim = 1
    xmin = 0
    xmax = 10
    nx = 50
  [../]
[]

[Variables]
  [./v]
    family = MONOMIAL
    order = CONSTANT
    fv = true
  [../]
[]

[ICs]
  [./v_ic]
    type = FunctionIC
    variable = v
    function = &#x27;if (x &gt; 2 &amp; x &lt; 3, 0.5, 0)&#x27;
  [../]
[]

[FVKernels]
  [./burgers]
    type = FVBurgers1D
    variable = v
  [../]
  [./time]
    type = FVTimeKernel
    variable = v
  [../]
[]

[FVBCs]
  [./fv_burgers_outflow]
    type = FVBurgersOutflowBC
    variable = v
    boundary = &#x27;left right&#x27;
  [../]
[]

[Executioner]
  type = Transient
  petsc_options_iname = &#x27;-pc_type&#x27;
  petsc_options_value = &#x27;lu&#x27;
  petsc_options = &#x27;-snes_converged_reason&#x27;
  nl_abs_tol = 1e-7
  nl_rel_tol = 1e-8
  num_steps = 5
  dt = 0.05
[]

[Outputs]
  exodus = true
[]
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="dd854ee5-1b78-4cb8-815e-c513a8664e13"><div class="modal-content"><h4>(moose/framework/src/fvkernels/FVDiffusion.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;FVDiffusion.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FVDiffusion);

InputParameters
FVDiffusion::validParams()
{
  InputParameters params = FVFluxKernel::validParams();
  params.addClassDescription(&quot;Computes residual for diffusion operator for finite volume method.&quot;);
  params.addRequiredParam&lt;MaterialPropertyName&gt;(&quot;coeff&quot;, &quot;diffusion coefficient&quot;);
  params.set&lt;unsigned short&gt;(&quot;ghost_layers&quot;) = 2;
  return params;
}

FVDiffusion::FVDiffusion(const InputParameters &amp; params)
  : FVFluxKernel(params),
    _coeff_elem(getADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;)),
    _coeff_neighbor(getNeighborADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;))
{
}

ADReal
FVDiffusion::computeQpResidual()
{
  auto dudn = gradUDotNormal();

  // Eventually, it will be nice to offer automatic-switching triggered by
  // input parameters to change between different interpolation methods for
  // this.
  ADReal k;
  interpolate(Moose::FV::InterpMethod::Average,
              k,
              _coeff_elem[_qp],
              _coeff_neighbor[_qp],
              *_face_info,
              true);

  return -1 * k * dudn;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="8eb53790-538b-4382-ba64-042aea4a3511"><div class="modal-content"><h4>(moose/framework/src/fvkernels/FVDiffusion.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;FVDiffusion.h&quot;

registerMooseObject(&quot;MooseApp&quot;, FVDiffusion);

InputParameters
FVDiffusion::validParams()
{
  InputParameters params = FVFluxKernel::validParams();
  params.addClassDescription(&quot;Computes residual for diffusion operator for finite volume method.&quot;);
  params.addRequiredParam&lt;MaterialPropertyName&gt;(&quot;coeff&quot;, &quot;diffusion coefficient&quot;);
  params.set&lt;unsigned short&gt;(&quot;ghost_layers&quot;) = 2;
  return params;
}

FVDiffusion::FVDiffusion(const InputParameters &amp; params)
  : FVFluxKernel(params),
    _coeff_elem(getADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;)),
    _coeff_neighbor(getNeighborADMaterialProperty&lt;Real&gt;(&quot;coeff&quot;))
{
}

ADReal
FVDiffusion::computeQpResidual()
{
  auto dudn = gradUDotNormal();

  // Eventually, it will be nice to offer automatic-switching triggered by
  // input parameters to change between different interpolation methods for
  // this.
  ADReal k;
  interpolate(Moose::FV::InterpMethod::Average,
              k,
              _coeff_elem[_qp],
              _coeff_neighbor[_qp],
              *_face_info,
              true);

  return -1 * k * dudn;
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div><div class="moose-modal modal" id="e236563c-3d71-498a-ba40-098b71609892"><div class="modal-content"><h4>(moose/framework/src/fvkernels/FVTimeKernel.C)</h4><pre class="moose-pre"><code class="language-cpp">// This file is part of the MOOSE framework
// https://www.mooseframework.org
//
// All rights reserved, see COPYRIGHT for full restrictions
// https://github.com/idaholab/moose/blob/master/COPYRIGHT
//
// Licensed under LGPL 2.1, please see LICENSE for details
// https://www.gnu.org/licenses/lgpl-2.1.html

#include &quot;FVTimeKernel.h&quot;

#include &quot;SystemBase.h&quot;

registerADMooseObject(&quot;MooseApp&quot;, FVTimeKernel);

InputParameters
FVTimeKernel::validParams()
{
  InputParameters params = FVElementalKernel::validParams();
  params.addClassDescription(
      &quot;Residual contribution from time derivative of a variable for the finite volume method.&quot;);
  params.set&lt;MultiMooseEnum&gt;(&quot;vector_tags&quot;) = &quot;time&quot;;
  params.set&lt;MultiMooseEnum&gt;(&quot;matrix_tags&quot;) = &quot;system time&quot;;
  return params;
}

FVTimeKernel::FVTimeKernel(const InputParameters &amp; parameters)
  : FVElementalKernel(parameters), _u_dot(_var.adUDot())
{
}

ADReal
FVTimeKernel::computeQpResidual()
{
  return _u_dot[_qp];
}
</code></pre></div><div class="modal-footer"><a class="modal-close btn-flat">Close</a></div></div></div><div class="col hide-on-med-and-down l2"><div class="toc-wrapper pin-top"><ul class="section table-of-contents"><li><a href="#e2d0c9d7-6cbb-449d-a706-881d3e9c5630" class="tooltipped" data-position="left" data-tooltip="FVKernels block">FVKernels block</a></li><li><a href="#9beb0ace-76eb-4d3f-b91a-a4c4f73af215" class="tooltipped" data-position="left" data-tooltip="Available Objects">Available Objects</a></li><li><a href="#276882c1-4242-4462-9f64-598c0d1dc519" class="tooltipped" data-position="left" data-tooltip="FVKernel source code : FVDiffusion example">FVKernel source code : FVDiffusion example</a></li><li><a href="#bbd2c3de-f68e-44e9-a7ab-07345fe30af8" class="tooltipped" data-position="left" data-tooltip="FVKernel source code : FVMatAdvection example">FVKernel source code : FVMatAdvection example</a></li><li><a href="#9291d28c-5e6e-44cd-88f4-302e138b8bae" class="tooltipped" data-position="left" data-tooltip="FVKernel source code : FVTimeKernel">FVKernel source code : FVTimeKernel</a></li></ul></div></div></div></div></main></div></body><script type="text/javascript" src="../../contrib/materialize/materialize.min.js"></script><script type="text/javascript" src="../../contrib/clipboard/clipboard.min.js"></script><script type="text/javascript" src="../../contrib/prism/prism.min.js"></script><script type="text/javascript" src="../../js/init.js"></script><script type="text/javascript" src="../../js/navigation.js"></script><script type="text/javascript" src="../../contrib/fuse/fuse.min.js"></script><script type="text/javascript" src="../../js/search_index.js"></script><script type="text/javascript" src="../../js/sqa_moose.js"></script>